int	get_pixel_color(t_img *img, int x, int y, int width, int height)
{
	char	*dst;

	if (x < 0 || x > width || y < 0 || y > height)
		return (1);
	dst = (char *)img->dump + (y * img->size_l + x * (img->bpp / 8));
	return (*(unsigned int *)dst);
}

// int	get_pixel_color(t_img texture, int offset_x, int offset_y)
// {
// 	int	pixel_color;

// 	if (offset_x < 0 || offset_x > texture.width
// 		|| offset_y < 0 || offset_y > texture_height)
// 		return (1);
// 	pixel_color = texture.dump[(texture.width * offset_y) + offset_x];
// 	return (pixel_color);
// }

static void	init_draw_line(t_line *line)
{
	line->dx = abs(line->x1 - line->x0);
	line->dy = -abs(line->y1 - line->y0);
	if (line->x0 < line->x1)
		line->sx = 1;
	else
		line->sx = -1;
	if (line->y0 < line->y1)
		line->sy = 1;
	else
		line->sy = -1;
	line->err = line->dx + line->dy;
}

void	draw_line(t_img *img, t_line line)
{
	init_draw_line(&line);
	while (1)
	{
		if (line.x0 == line.x1 && line.y0 == line.y1)
			break ;
		if (line.x0 < 0 || line.x0 >= WIN_WIDTH
			|| line.y0 < 0 || line.y0 >= WIN_HEIGHT)
			break ;
		pixel_put(img, line.x0, line.y0, line.color);
		line.e2 = 2 * line.err;
		if (line.e2 >= line.dy)
		{
			line.err += line.dy;
			line.x0 += line.sx;
		}
		if (line.e2 <= line.dx)
		{
			line.err += line.dx;
			line.y0 += line.sy;
		}
	}
}

void	draw_vert_pixel(t_img *img, int x0, int y0, int thick, int color)
{
	int	i;

	i = -1;
	while (++i < thick)
		my_mlx_pixel_put(img, x0 + i, y0, color);
}

void	fill_color(t_img *img, int color)
{
	int		count_w;
	int		count_h;

	count_h = -1;
	while (++count_h < IMG_HEIGHT)
	{
		count_w = -1;
		while (++count_w < IMG_WIDTH)
			img->dump[count_h * IMG_WIDTH + count_w] = color;
	}
}

void	copy_layer(t_img *img_src, t_img *img_dst, int color)
{
	int		count_w;
	int		count_h;

	count_h = -1;
	while (++count_h < IMG_HEIGHT)
	{
		count_w = -1;
		while (++count_w < IMG_WIDTH)
		{
			if (img_dst->dump[count_h * IMG_WIDTH + count_w] == color)
				img_dst->dump[count_h * IMG_WIDTH + count_w]
					= img_src->dump[count_h * IMG_WIDTH + count_w];
		}
	}
}

void	draw_map(t_data *data)
{
	int		x;
	int		y;
	t_img	*img;
	t_rect	rect;

	rect.width = TILE_SIZE * MINIMAP_SCALE_FACTOR;
	rect.height = TILE_SIZE * MINIMAP_SCALE_FACTOR;
	img = &data->img[MAP];
	y = -1;
	while (++y < map_height(data))
	{
		x = -1;
		while (++x < map_width(data))
		{
			rect.x = x * TILE_SIZE * MINIMAP_SCALE_FACTOR;
			rect.y = y * TILE_SIZE * MINIMAP_SCALE_FACTOR;
			if (ftex_is_in_set(data->map[y][x], "!@"))
				rect.color = WHITE;
			else if (ftex_is_in_set(data->map[y][x], "0N"))
				rect.color = BLACKB;
			else
				continue ;
			draw_rect(img, rect);
		}
	}
}

void	draw_player(t_data *data)
{
	t_img		*img;
	t_player	player;
	t_line		line;

	img = &data->img[PLAYER];
	player = data->player;
	line.x0 = 50 + 115;
	line.y0 = (WIN_HEIGHT - 270) + 115;
	line.x1 = line.x0 + cos(player.rot_angle) * 15;
	line.y1 = line.y0 + sin(player.rot_angle) * 15;
	line.color = YELLOW;
	draw_line(img, line);
}

typedef struct s_rect
{
	int	x;
	int	y;
	int	width;
	int	height;
	int	color;
}	t_rect;


void	draw_rect(t_img *img, t_rect rect)
{
	int		x;
	int		y;

	rect.height += rect.y;
	rect.width += rect.x;
	y = rect.y - 1;
	while (++y < rect.height)
	{
		x = rect.x - 1;
		while (++x < rect.width)
			pixel_put(img, x, y, rect.color);
	}
}

static void	mouse_handler_x(int x, int mid_x, int mid_y, t_data *data)
{
	static int	new_x;
	t_player	*player;

	player = &data->player;
	if (x != new_x && (abs(new_x - x) > 0))
	{
		if (new_x > x)
			player->rot_angle -= abs(new_x - x) / (data->frame.delta_time * 7000);
		if (new_x < x)
			player->rot_angle += abs(new_x - x) / (data->frame.delta_time * 7000);
		if (x > mid_x || x < mid_x)
			mlx_mouse_move(data->mlx.mlx_ptr, data->mlx.win, mid_x, mid_y);
		new_x = mid_x;
	}
}

static void	mouse_handler_y(int y, int mid_x, int mid_y, t_data *data)
{
	static int	new_y;
	t_player	*player;

	player = &data->player;
	if (y != new_y && (abs(new_y - y) > 0))
	{
		if (new_y > y)
			player->view_angle += abs(new_y - y) / (data->frame.delta_time * 5);
		if (new_y < y)
			player->view_angle -= abs(new_y - y) / (data->frame.delta_time * 5);
		if (y > mid_y || y < mid_y)
			mlx_mouse_move(data->mlx.mlx_ptr, data->mlx.win, mid_x, mid_y);
		new_y = mid_y;
	}
}

int	is_wall_side_door(t_ray ray, t_data *data)
{
	int	map_x;
	int	map_y;

	map_x = (int)floor(ray.wall_hit_x / TILE_SIZE);
	map_y = (int)floor(ray.wall_hit_y / TILE_SIZE);
	if (!ray.was_hit_vertical)
	{
		if (get_map_value_at(map_x + 1, map_y, data) == 'H')
			return (true);
		if (get_map_value_at(map_x - 1, map_y, data) == 'H')
			return (true);
	}
	else
	{
		if (get_map_value_at(map_x, map_y + 1, data) == 'H')
			return (true);
		if (get_map_value_at(map_x, map_y - 1, data) == 'H')
			return (true);
	}
	return (false);
}
